# Leetcode记录
## 1.两数之和
### 暴力枚举
暴力枚举：枚举i再枚举j，两层for循环判断nums[i] + nums[j] == target
```c
int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    for (int i = 0; ; i++) { // 枚举 i
        for (int j = i + 1; j < numsSize; j++) { // 枚举 i 右边的 j
            if (nums[i] + nums[j] == target) { 
                int* ret = malloc(2 * sizeof(int)); // 分配返回结果的内存空间
                *returnSize = 2; // ans 的长度
                ret[0] = i;
                ret[1] = j;
                *returnSize = 2;
                return ret;
            }
        }
    }
}
```
### 哈希表
哈希表法：由键（key）和值（val）构成哈希表，遍历数组，例数组为：
```c
Sum = [4,3,1,7,0];
```
例如target为5，当前指针为4，在哈希表中没有寻找到1，那么将key值和val下标存入哈希表中，再遍历第二位3，在哈希表中没有寻找到2，继续存储，当遍历至1，在哈希表中搜索到了4，下标为0，完成全部算法过程，返回{0，2}<br>
完整代码：
```c
struct HashTable {
    int key;
    int val;
    UT_hash_handle hh; // hash handle（哈希句柄）的缩写
};

struct HashTable* hashtable;

// 寻找 
struct HashTable* find(int ikey) {
    struct HashTable* tmp;
    HASH_FIND_INT(hashtable, &ikey, tmp);
    return tmp;
}

// 插入
void insert(int ikey, int ival) {
    struct HashTable* it = find(ikey);
    if (it == NULL) {
        struct HashTable* tmp = malloc(sizeof(struct HashTable));
        tmp->key = ikey, tmp->val = ival;
        HASH_ADD_INT(hashtable, key, tmp);
    } else {
        it->val = ival;
    }
}

int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    hashtable = NULL;
    for (int i = 0; i < numsSize; i++) {
        struct HashTable* it = find(target - nums[i]);
        if (it != NULL) {
            int* ret = malloc(sizeof(int) * 2);
            ret[0] = it->val, ret[1] = i;
            *returnSize = 2;
            return ret;
        }
        insert(nums[i], i);
    }
    *returnSize = 0;
    return NULL;
}
```
## 2.异位词分组
### 哈希表
```c
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> i;
        for (string& s : strs) {
            string sorted_s = s;
            ranges::sort(sorted_s); // 把 s 排序，作为哈希表的 key
            i[sorted_s].push_back(s); // 排序后相同的字符串分到同一组
        }

        vector<vector<string>> ans;
        ans.reserve(i.size()); // 预分配空间
        for (auto& [_, value] : i) {
            ans.push_back(value); // 哈希表的 value 保存分组后的结果
        }
        return ans;
    }
};

```