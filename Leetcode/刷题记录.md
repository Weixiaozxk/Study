# Leetcode记录
## 1.两数之和
### 暴力枚举
暴力枚举：枚举i再枚举j，两层for循环判断nums[i] + nums[j] == target
```c
int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    for (int i = 0; ; i++) { // 枚举 i
        for (int j = i + 1; j < numsSize; j++) { // 枚举 i 右边的 j
            if (nums[i] + nums[j] == target) { 
                int* ret = malloc(2 * sizeof(int)); // 分配返回结果的内存空间
                *returnSize = 2; // ans 的长度
                ret[0] = i;
                ret[1] = j;
                *returnSize = 2;
                return ret;
            }
        }
    }
}
```
### 哈希表
哈希表法：由键（key）和值（val）构成哈希表，遍历数组，例数组为：
```c
Sum = [4,3,1,7,0];
```
例如target为5，当前指针为4，在哈希表中没有寻找到1，那么将key值和val下标存入哈希表中，再遍历第二位3，在哈希表中没有寻找到2，继续存储，当遍历至1，在哈希表中搜索到了4，下标为0，完成全部算法过程，返回{0，2}<br>
完整代码：
```c
struct HashTable {
    int key;
    int val;
    UT_hash_handle hh; // hash handle（哈希句柄）的缩写
};

struct HashTable* hashtable;

// 寻找 
struct HashTable* find(int ikey) {
    struct HashTable* tmp;
    HASH_FIND_INT(hashtable, &ikey, tmp);
    return tmp;
}

// 插入
void insert(int ikey, int ival) {
    struct HashTable* it = find(ikey);
    if (it == NULL) {
        struct HashTable* tmp = malloc(sizeof(struct HashTable));
        tmp->key = ikey, tmp->val = ival;
        HASH_ADD_INT(hashtable, key, tmp);
    } else {
        it->val = ival;
    }
}

int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    hashtable = NULL;
    for (int i = 0; i < numsSize; i++) {
        struct HashTable* it = find(target - nums[i]);
        if (it != NULL) {
            int* ret = malloc(sizeof(int) * 2);
            ret[0] = it->val, ret[1] = i;
            *returnSize = 2;
            return ret;
        }
        insert(nums[i], i);
    }
    *returnSize = 0;
    return NULL;
}
```
## 2.异位词分组
### 哈希表
对字母进行排序，排完序作为一个抽屉标签为key，原始单词为物品放到抽屉内，为value，把哈希表中的value放到新表中return
```c
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> i;
        for (string& s : strs) {
            string sorted_s = s;
            ranges::sort(sorted_s); // 把 s 排序，作为哈希表的 key
            i[sorted_s].push_back(s); // 排序后相同的字符串分到同一组
        }

        vector<vector<string>> ans;
        ans.reserve(i.size()); // 预分配空间
        for (auto& [_, value] : i) {
            ans.push_back(value); // 哈希表的 value 保存分组后的结果
        }
        return ans;
    }
};

```
## 3.最长连续序列
### 哈希表
在一堆杂乱的数字，找到最长的连续数字有多少<br>
利用unordered_set把所有数字装起来，然后检查每个数组里的数字，看这个数字-1是否在这个unordered_set中，没有则为起点继续记录连续数字给计数器（seqlen），直到下一个数字不在表里，更新到res并返回值。
```c
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
       int res =0;
        unordered_set<int> num_set(nums.begin(), nums.end());   // 记录nums中的所有数值
        int seqLen;
        for(int num: num_set){
            // 如果当前的数是一个连续序列的起点，统计这个连续序列的长度
            if(!num_set.count(num - 1)){
                seqLen = 1;     // 连续序列的长度，初始为1
                while(num_set.count(++num))
                    seqLen++;    // 不断查找连续序列，直到num的下一个数不存在于数组中
                    res = max(res, seqLen);  // 更新最长连续序列长度
            }
        }
        return res;
    }
};
```
## 4.移动零
### 双指针
```c
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size(), left = 0, right = 0; //right找非0元素，left记录非0元素
        while (right < n) {         //循环从0到4
            if (nums[right]) {      //非0就继续
                swap(nums[left], nums[right]);      //交换
                left++;     //记录非0次数
            }
            right++;        //找下一个数组
        }
    }
};
```
## 5.盛最多水的容器
### 双指针
```c
class Solution {
public:
    int maxArea(vector<int>& height) {
        int res = 0; //最大装水量，为返回值
        int i = 0;  //左指针，左边线段位置x坐标
        int j = height.size() - 1;  //右指针，右边线段位置x坐标

        while(i < j){
            int area = (j - i) * min(height[i] , height[j]);
            res = max(res , area);
            if(height[i] < height[j]){  //移动矮的那方，高度不能受限
                ++i;
            }
            else --j;
        }
        return res;
    }
};
```